---
layout: post
title: CQRS
tags: [Design Pattern, Architecture, Database, Command, Query]
comments: true
mathjax: true
author: 이희두
---


## CQRS란?

**CQRS (Command Query Responsibility Segregation)** 는

**데이터 변경(Command)** 과 **데이터 조회(Query)** 의 책임을 명확히 분리하는 아키텍처 패턴이다.

- **Command**
    - 상태를 변경하는 작업 (Create / Update / Delete)
    - 비즈니스 규칙, 검증, 트랜잭션, 동시성 제어 담당
- **Query**
    - 상태를 조회하는 작업 (Read)
    - 변경 없이 필요한 데이터만 빠르게 반환

CQRS는 단순히 클래스 레벨에 국한되지 않고,

- 클래스
- 패키지
- 모듈
- 서비스
- 데이터 저장소(DB)

등 **다양한 레벨에서 적용 가능**하다.

---

## CQRS가 필요한 이유

### 모듈 간 의존성 증가와 순환 참조 문제

- 하나의 모델이 **조회 + 수정 책임을 모두 가질 경우**
- 여러 모듈이 서로를 참조하게 되고
- 결국 **강한 결합 + 순환 참조** 문제가 발생

CQRS는 **읽기 / 쓰기 모듈을 분리**하여

각 모듈을 **독립적으로 관리**할 수 있게 해준다.

---

### 조회와 수정 간 동시성 문제

- 조회는 많고 수정은 적은 경우
- 조회 트래픽이 쓰기 트랜잭션에 영향을 주거나
- Lock, 트랜잭션 범위 확대로 성능 저하 발생

CQRS는

- 쓰기: 일관성과 정합성 중심
- 읽기: 성능과 응답 속도 중심
    
    으로 설계할 수 있다.
    

---

### 단일 모델의 책임 과다 및 성능 저하

하나의 DB 모델이 다음을 모두 담당하면:

- 쓰기 시 검증 로직
- 복잡한 조회 쿼리
- 다양한 조인
- 필요 이상의 데이터 로딩

**모델이 비대해지고 성능 저하** 발생

CQRS는

- 쓰기 모델: 정합성 중심
- 읽기 모델: 조회 최적화 중심
    
    으로 역할을 분리한다.
    

---

## CQRS의 장점

### 1. 읽기 / 쓰기 격리를 통한 DB 분리 가능

- 쓰기 DB: RDB (MySQL, PostgreSQL 등)
- 읽기 DB: Redis, Elasticsearch, Read Replica 등

→  트래픽 특성에 맞는 DB 선택 가능

---

### 2. 보안 및 접근 제어 강화

- 쓰기 API는 제한
- 조회 API는 공개 범위 확대 가능

→  권한 설계가 명확해짐

---

### 3. 조회 성능 극대화

- 조회 전용 테이블
- 조인 없는 구조
- 미리 계산된 데이터 저장

**→ 응답 속도와 확장성 향상**

---

## 최적화된 CQRS 적용 전략 (실무 관점)

### 모듈 단위 CQRS

### 쓰기 모듈

- 검증
- 비즈니스 로직
- 트랜잭션
- 상태 변경

### 읽기 모듈

- 복잡한 로직 없이
- 클라이언트에 필요한 데이터만 반환
- 단순 DTO 중심

---

### 데이터 저장소 단위 CQRS

- **쓰기**
    - 기존 RDB 유지
    - 정합성 중심 설계
- **읽기**
    - Redis / Elasticsearch / 조회 전용 DB
    - 조회에 최적화된 구조 사용

---

### 읽기 전용 테이블 설계

- 여러 테이블 조인 X
- 필요한 데이터만 **정규화 / 비정규화**해서 저장
- 화면 단위(View Model)로 설계

---

### 조회 우선순위 전략

- 조회가 **자주 발생하는 핵심 데이터**
    - 미리 저장 (캐시 or Read DB)
- 조회 빈도가 낮은 데이터
    - 필요 시 쓰기 모듈에 요청
    - 결과를 다시 읽기 모델에 반영

**비용 대비 효율적인 CQRS 운영**
