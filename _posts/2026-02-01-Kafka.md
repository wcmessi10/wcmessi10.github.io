---
layout: post
title: Kafka
tags: [Kafka, Distributed Event Streaming Platform, Pub/Sub, Distributed Messaging System]
comments: true
mathjax: true
author: 이희두
---


## Kafka Cluster란

Kafka Cluster는 여러 Broker로 구성된 분산 이벤트 스트리밍 플랫폼이다.

Pub/Sub 모델을 기반으로 하며,
Producer와 Consumer 사이에서 데이터를 저장·전달하는
분산 메시징 시스템 역할을 한다.

대규모 데이터를 실시간으로 처리할 수 있도록 설계되었다.

## Topic

Kafka에서 생산 및 소비되는 데이터를 논리적으로 구분하는 단위

Producer : Topic 단위로 이벤트를 생산 및 전송

Consumer : Topic 단위로 이벤트를 구독 및 소비

Topic 안에서 Partition이라는 여러개의 물리적 단위로 분산이 가능하다.

Producer가 파티션을 지목하여 저장하거나, 아니면 라운드로빈 방식으로 저장할 수 있다. → 순서 보장 가능

메시지의 순서는 Partition 단위로만 보장된다.

## Kafka Broker란?

Kafka Cluster 안에서 Producer가 발행한 데이터를 중간에서 적재하여 데이터 허브 역할을 한다.

Kafka Cluster 안에서 여러개의 Broker를 구성하여 병렬로 처리할 수 있다.

Topic 안에서의 분리되어 있는 Partition들을 여러개의 Broker가 균등하게 분산될 수 있다.

ex) Kafka Cluster안에서 Topic ‘A’를 파티션 4개로 쪼개, 4개의 Kafka Broker에게 균등하게 처리할 수 있도록 파티션 1개씩 분담하여 처리량과 안정성을 확보한다.

## Topic의 Partition의 Replication Factor

Kafka Broker 장애 방지를 위해 Topic의 Partition은 복제본을 관리할 수 있다.

Replication Factor를 설정을 하면 여러개로 복제가 가능하다

Leader : Producer, Consumer의 데이터 쓰기 읽기 담당한다.

Follower : Leader는 Follwer에게 데이터를 복제한다.

Leader와 Follower 복제본들은 Broker 여러개에 분산이 가능하다.

### 복제 관련 설정

Producer에서는 Leader와 Follower의 저장 확인 혹은 복제 확인 여부를 설정할 수 있다. 이를 acks라고 한다.

acks=0 : Broker에 데이터가 전달되었는지 확인조차 안한다. 속도는 빠르나, 데이터 유실 가능성이 높다.

acks=1 : Partition의 Leader안에 저장되면 성공처리한다. Follower 전달 여부는 확인하지 않는다. Broker 장애 시 데이터 손실 가능성 있다.

acks=All : Leader와 모든 Follwer에 데이터 저장 시 성공처리한다. 가장 안전하나, 속도가 느리다. min.insync.replicas : leader의 데이터가 복제본으로 동기화되어있는 Follower를 나타내는 ‘ISR’이 몇 개가 있어야하는지 여부를 설정한다. 

ex) acks=All, min.insync.replicas=3, replication factor=5라면? : 복제본은 총 5개이지만 3개 저장 성공 시 Producer 성공 처리

### Broker 장애 시 Replication의 대응 방식

특정 Topic의 Leader Partition을 가지고 있는 Broker 장애 발생 시  → 그 외의 Broker들이 보유한 Follower Partition 중 Leader Partition 재선출

## Consumer의 Kafka에서 구독 방식

Kafka는 데이터를 순서대로 Offset이라는 고유 숫자로 데이터를 보유하고 있다. Consumer는 데이터를 처리할 때 이 Offset을 통해 다음 순서를 이어 처리할 수 있다. 

Consumer가 여러 개일 경우, 같은 처리를 병렬로 할 경우 Offset 순서가 혼동하지 않도록 같은 처리하는 Consumer들끼리 그룹을 나눈다. 이를 Consumer Group이라고 한다.

ex) Consumer가 4개정도 있다. 2개마다 데이터 처리 목적이 다르고, 그 목적은 서로의 목적과 다르므로 offset 순서가 서로 공유되어서는 안된다. 그래서 목적이 같은 Consumer끼리 그룹을 하여 각 그룹끼리만 offset 순서를 공유한다.

## Zookeeper

Kafka의 메타데이터를 관리하는 시스템 (위에서 말한 topic, partition, replication 등등)

고가용성을 위해 클러스터링이 가능하다.

→ Kafka 2.8 버전 이후부터는 Kafka Broker 자체적으로 메타데이터 관리할 수 있게 되었다. KRaft 모드라고 한다.

## Kafka의 장점 및 특징

### 고성능

Kafka는 초당 수십만~수백만 건의 메시지를 처리할 수 있다.

- **Append-only 로그 구조**
    - 기존 데이터를 수정, 삭제하지 않고 뒤에 계속 추가만 하는 방식
    - 디스크 순차 I/O 사용으로 매우 빠른 처리
- **배치 전송**
    - 여러 메시지를 묶어 처리
- **Zero-copy 전송**
    - OS 레벨 최적화

대용량 로그, IoT, 실시간 데이터 처리에 적합

### 2. 확장성

Kafka는 **수평 확장**이 가능하다.

- Topic을 Partition으로 분산
- Broker 추가 시 처리량 증가
    - 트래픽 증가 → Broker 추가 → 성능 선형 증가

대규모 서비스에 유리

### 3. 고가용성

Kafka는 장애에 강하다.

- Partition 복제 (Replication)
- Leader/Follower 구조
- Broker 장애 시 자동 Leader 재선출

일부 서버 장애 시에도 서비스 지속 가능

### 4. 내구성

Kafka는 데이터를 디스크에 저장한다.

- 메시지 로그 보관
- 복제본 유지
- acks 설정으로 안정성 제어

### 5. 메시지 재처리 가능

Kafka는 메시지를 즉시 삭제하지 않는다.

- 과거 데이터 재처리 가능
- 장애 복구 용이
- 데이터 리플레이 가능

디버깅 및 데이터 분석에 매우 유리

### 6. 느슨한 결합 (Loose Coupling)

Producer와 Consumer가 직접 연결되지 않는다.

- 시스템 간 의존성 감소
- 서비스 추가/변경 용이
- MSA 구조에 적합

### 7. 실시간 스트리밍 처리

Kafka는 단순 메시지 전달뿐 아니라 **스트리밍 플랫폼 역할**도 수행한다.

- Kafka Streams
- 실시간 분석
- 실시간 ETL
