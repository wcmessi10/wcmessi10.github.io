---
layout: post
title: Caffeine 로컬 캐시 TTL 및 정책 정리 문서
tags: [Backend, Spring, Cache]
comments: true
mathjax: true
author: 이희두
---

# Caffeine 로컬 캐시 TTL 및 정책 정리 문서

## 요약

- Caffeine 로컬 캐시를 사용하여 **클라이언트 애플리케이션, 관리자 시스템, 외부 연동 API** 전반의 성능 개선
- 로컬 캐시는 **3분, 30분, 하루, 한 주, 한 달 단위**로 TTL을 구분하여 운영
- 관리자 시스템에서 데이터 수정이 발생할 경우,  
  **비즈니스 로직에 따라 특정 캐시를 선택적으로 삭제하기 위한 내부 캐시 삭제 API 구현**
- 현재 캐시 적용 대상:
  - 사용자 지갑성 데이터
  - 지역 및 서비스 메타 정보
  - 사용자 정보 중 변경 빈도가 낮은 데이터

---

## 1. 캐시 시스템 비교 개요 (Redis vs Caffeine)

| 항목 | Redis | Caffeine |
| --- | --- | --- |
| 저장 위치 | 외부 인메모리 DB (네트워크 접근) | JVM 내부 메모리 |
| TTL 설정 방식 | `EXPIRE`, `RedisCacheConfig` 등 | `.expireAfterWrite()` 등 |
| 장점 | 분산 환경 지원, 영속성 옵션, 다양한 자료구조 | 매우 빠른 응답 속도, GC 기반 자동 제거 |
| 단점 | 네트워크 비용, 외부 인프라 필요 | JVM 종료 시 휘발성, Heap 메모리 사용 |

---

## 2. Caffeine TTL(Time To Live) 설정 방법

### 1) Spring 기반 TTL 설정 (전역)

#### Gradle 의존성 추가

```gradle
implementation 'com.github.ben-manes.caffeine:caffeine'
implementation 'org.springframework.boot:spring-boot-starter-cache'
````

#### application.yml 설정

```yaml
app:
  cache:
    short-lived:
      ttl-minutes: 3
      max-size: 20000
    long-lived:
      ttl-minutes: 30
      max-size: 10000
    day-lived:
      ttl-minutes: 1440
      max-size: 5000
    week-lived:
      ttl-minutes: 10080
      max-size: 2000
    month-lived:
      ttl-minutes: 43200
      max-size: 300
```

#### Cache Properties 정의

```java
@ConfigurationProperties(prefix = "app.cache")
@Component
@Getter
@Setter
public class CacheProperties {

    private CacheSpec shortLived;
    private CacheSpec longLived;
    private CacheSpec dayLived;
    private CacheSpec weekLived;
    private CacheSpec monthLived;

    @Getter
    @Setter
    public static class CacheSpec {
        private int ttlMinutes;
        private int maxSize;
    }
}
```

#### Caffeine Cache Config

```java
@Configuration
@EnableCaching
public class CaffeineCacheConfig {

    private final CacheProperties cacheProps;

    public CaffeineCacheConfig(CacheProperties cacheProps) {
        this.cacheProps = cacheProps;
    }

    @Bean
    public CacheManager cacheManager() {
        SimpleCacheManager manager = new SimpleCacheManager();

        List<CaffeineCache> caches = List.of(
            new CaffeineCache("shortLivedCache",
                Caffeine.newBuilder()
                    .expireAfterWrite(cacheProps.getShortLived().getTtlMinutes(), TimeUnit.MINUTES)
                    .maximumSize(cacheProps.getShortLived().getMaxSize())
                    .build()),

            new CaffeineCache("longLivedCache",
                Caffeine.newBuilder()
                    .expireAfterWrite(cacheProps.getLongLived().getTtlMinutes(), TimeUnit.MINUTES)
                    .maximumSize(cacheProps.getLongLived().getMaxSize())
                    .build()),

            new CaffeineCache("dayLivedCache",
                Caffeine.newBuilder()
                    .expireAfterWrite(cacheProps.getDayLived().getTtlMinutes(), TimeUnit.MINUTES)
                    .maximumSize(cacheProps.getDayLived().getMaxSize())
                    .build()),

            new CaffeineCache("weekLivedCache",
                Caffeine.newBuilder()
                    .expireAfterWrite(cacheProps.getWeekLived().getTtlMinutes(), TimeUnit.MINUTES)
                    .maximumSize(cacheProps.getWeekLived().getMaxSize())
                    .build()),

            new CaffeineCache("monthLivedCache",
                Caffeine.newBuilder()
                    .expireAfterWrite(cacheProps.getMonthLived().getTtlMinutes(), TimeUnit.MINUTES)
                    .maximumSize(cacheProps.getMonthLived().getMaxSize())
                    .build())
        );

        manager.setCaches(caches);
        return manager;
    }
}
```

#### 캐시 적용 메소드 예시

```java
@Cacheable(
    cacheNames = "weekLivedCache",
    key = "id + '.' + #root.targetClass.name + '.' + #root.methodName"
)
public String findNameById(Integer id) {
    return repository.findById(id)
                     .orElseThrow()
                     .getName();
}
```

---

## 3. 캐시 삭제 전략

### 1) 캐시 삭제용 내부 API

```java
@DeleteMapping("/deleteCache")
public ResponseEntity<Void> deleteCache(
        @RequestParam String cacheName,
        @RequestParam String key
) {
    cacheService.deleteCache(cacheName, key);
    return ResponseEntity.noContent().build();
}
```

### 2) 관리자 시스템 – 캐시 삭제 비동기 호출 유틸

```java
@Slf4j
@Component
public class DeleteCacheUtil {

    @Value("${app.server}")
    private String appServerUrl;

    @Async
    public void deleteCache(CacheName cacheName, String... keys) throws IOException {
        String key = cacheName.generateKey(keys);
        String url = String.format(
            "%s/deleteCache?cacheName=%s&key=%s",
            appServerUrl,
            cacheName.getCacheName(),
            key
        );
        sendDeleteRequest(url);
    }

    private void sendDeleteRequest(String urlString) throws IOException {
        HttpURLConnection connection =
            (HttpURLConnection) new URL(urlString).openConnection();

        connection.setRequestMethod(HttpMethod.DELETE.name());
        connection.setRequestProperty(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON_VALUE);
        connection.setDoOutput(true);

        int responseCode = connection.getResponseCode();
        log.info("Cache delete response: {}", responseCode);
        connection.disconnect();
    }
}
```

### 3) 캐시 이름 및 Key 관리 Enum

```java
@Getter
public enum CacheName {

    SEARCH("weekLivedCache", "%s.controller.search"),
    SEARCH_GEO_POINT("weekLivedCache", "%s.controller.searchGeoPoint"),
    GET_DETAIL("weekLivedCache", "%s.controller.getDetail"),
    USAGE_HISTORY("dayLivedCache", "%s.%s.%s.controller.getUsageHistory"),
    SUPPORT_CENTER_INFO("weekLivedCache", "%s.controller.supportCenterInfo"),
    USER_ASSET("shortLivedCache", "%s.controller.userAsset"),
    USER_ASSET_DETAIL("shortLivedCache", "%s.controller.userAssetDetail"),
    WARRANTY_DETAIL("weekLivedCache", "%s.controller.warrantyDetail"),
    FIND_NAME_BY_ID("weekLivedCache", "%s.controller.findNameById"),
    GET_ID("monthLivedCache", "%s.controller.getId"),
    USER_PROFILE("weekLivedCache", "%s.controller.userProfile"),
    CHECK_IDENTIFIER("monthLivedCache", "%s.controller.checkIdentifier"),
    STATIC_RESOURCE_LIST("monthLivedCache", "controller.findAll"),
    PARTNER_LIST("dayLivedCache", "%s.controller.partnerList"),
    PARTNER_DETAIL("dayLivedCache", "%s.controller.partnerDetail");

    private final String cacheName;
    private final String keyPattern;

    CacheName(String cacheName, String keyPattern) {
        this.cacheName = cacheName;
        this.keyPattern = keyPattern;
    }

    public String generateKey(String... keys) {
        int expected = keyPattern.split("%s", -1).length - 1;
        if (keys.length != expected) {
            throw new IllegalArgumentException(
                "Expected " + expected + " keys but got " + keys.length
            );
        }
        return String.format(keyPattern, (Object[]) keys);
    }
}
```

---

## 4. 캐시 적용 기준 및 대상

### 캐시 적용 기준

* 데이터 변경 빈도가 낮을 것
* 조회 빈도가 높을 것
* 일관성보다 **응답 성능이 더 중요한 영역일 것**

> 모든 도메인에 캐시를 적용하지 않고,
> **실제 트래픽 패턴과 데이터 특성을 기준으로 선별 적용**

### 적용 대상 예시

1. 사용자 지갑성 데이터 (사용자당 1개, 거의 불변)
2. 모델 / 상품 메타 정보
3. 보증 및 정책 정보
4. 지역 및 서비스 메타 정보
5. 사용자 프로필 중 변경 빈도가 낮은 데이터
6. 사용자 자산 정보

   * 요청 빈도가 높아 **짧은 TTL로 캐시 적용**
7. 정적 리소스 정보 (이미지, 메타 데이터)
